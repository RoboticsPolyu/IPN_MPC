#include "quadrotor_simulator/Dynamics_factor.h"

namespace UAVFactor
{
    int ActuatorEffectivenessRotors::computeEffectivenessMatrix(const Geometry &geometry, EffectivenessMatrix &effectiveness, 
        ActuatorEnabled &actuatorEnabled, boost::optional<gtsam::Matrix &> Jacobian)
    {
        int num_actuators = 0;

        for (int rotor_idx = 0; rotor_idx < geometry.num_rotors; rotor_idx++)
        {
            if (rotor_idx >= NUM_ACTUATORS)
            {
                break;
            }

            if(!actuatorEnabled(rotor_idx,1))
            {
                continue;
            }

            ++num_actuators;

            // Get rotor axis
            gtsam::Vector3 axis = geometry.rotors[rotor_idx].axis;

            // Normalize axis
            float axis_norm = axis.norm();

            if (axis_norm > FLT_EPSILON)
            {
                axis /= axis_norm;
            }
            else
            {
                // Bad axis definition, ignore this rotor
                continue;
            }

            // Get rotor position
            const gtsam::Vector3 &position = geometry.rotors[rotor_idx].position;

            // Get coefficients
            float ct = geometry.rotors[rotor_idx].thrust_coef;
            float km = geometry.rotors[rotor_idx].moment_ratio;

            if (geometry.propeller_torque_disabled)
            {
                km = 0.f;
            }

            if (geometry.propeller_torque_disabled_non_upwards)
            {
                bool upwards = std::abs(axis(0)) < 0.1f && std::abs(axis(1)) < 0.1f && axis(2) < -0.5f;

                if (!upwards)
                {
                    km = 0.f;
                }
            }

            if (std::abs(ct) < FLT_EPSILON)
            {
                continue;
            }

            // Compute thrust generated by this rotor
            gtsam::Vector3 thrust = ct * axis;

            // Compute moment generated by this rotor
            gtsam::Vector3 moment = ct * position.cross(axis) - ct * km * axis;

            // Fill corresponding items in effectiveness gtsam
            for (size_t j = 0; j < 3; j++)
            {
                effectiveness(j, rotor_idx) = moment(j);
                effectiveness(j + 3, rotor_idx) = thrust(j);
            }

            if (geometry.yaw_by_differential_thrust_disabled)
            {
                // set yaw effectiveness to 0 if yaw is controlled by other means (e.g. tilts)
                effectiveness(2, rotor_idx) = 0.f;
            }

            if (geometry.three_dimensional_thrust_disabled)
            {
                // Special case tiltrotor: instead of passing a 3D thrust vector (that would mostly have a x-component in FW, and z in MC),
                // pass the vector magnitude as z-component, plus the collective tilt. Passing 3D thrust plus tilt is not feasible as they
                // can't be allocated independently, and with the current controller it's not possible to have collective tilt calculated
                // by the allocator directly.

                effectiveness(0 + 3, rotor_idx) = 0.f;
                effectiveness(1 + 3, rotor_idx) = 0.f;
                effectiveness(2 + 3, rotor_idx) = -ct;
            }
        }

        return num_actuators;
    }


    Vector AllocationFactor::evaluateError(const double& thrust, const gtsam::Vector3 &moments, const gtsam::Vector4 &actuator_outputs,
                                           boost::optional<Matrix &> H1, boost::optional<Matrix &> H2,
                                           boost::optional<Matrix &> H3) const
    {
        gtsam::Vector4 err;

        return err;
    }
}